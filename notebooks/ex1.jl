### A Pluto.jl notebook ###
# v0.19.13

using Markdown
using InteractiveUtils

# This Pluto notebook uses @bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of @bind gives bound variables a default value (instead of an error).
macro bind(def, element)
    quote
        local iv = try Base.loaded_modules[Base.PkgId(Base.UUID("6e696c72-6542-2067-7265-42206c756150"), "AbstractPlutoDingetjes")].Bonds.initial_value catch; b -> missing; end
        local el = $(esc(element))
        global $(esc(def)) = Core.applicable(Base.get, el) ? Base.get(el) : iv(el)
        el
    end
end

# ╔═╡ 38e1939a-3c91-4b7b-88fd-ae7e01eda602
# Run notebook in Pluto.jl "backward compatibility mode" 
# using the so-called "global environment" pattern
# see https://github.com/fonsp/Pluto.jl/wiki/%F0%9F%8E%81-Package-management 
# for more details
begin
    import Pkg
    # activate the shared project environment
    Pkg.activate(Base.current_project())
    # instantiate, i.e. make sure that all packages are downloaded
    Pkg.instantiate()
end

# ╔═╡ 299c6e30-9107-4039-a11c-32ed6d9b1460
using DrWatson

# ╔═╡ b881120b-853d-4c0f-bcb8-b3b18e2dd9ae
@quickactivate "AutoExperimentsProjectTemplate"

# ╔═╡ 52a4a234-a99c-4e0d-b1e7-f54ddc11ff45
using DataFrames

# ╔═╡ 08a6ab1f-ef85-41a3-bb1a-933d578e4f93
using BSON

# ╔═╡ 696ffce0-e025-409c-8628-48b06fc7fd38
using PlutoUI

# ╔═╡ e82ad202-94eb-4f79-8aa3-7dd40375328b
using Plots

# ╔═╡ 106ded38-479d-4961-a127-24c2b416aa9d
md"""# Experiment 1 (mini-example)

This mini-example notebook reactively visualizes the following three single variable functions in a separate plot each:

$g(a)=f(b=\alpha,m=\beta,p=\gamma;a)$ 
$g(b)=f(a=\alpha,m=\beta,p=\gamma;b)$ 
$g(m)=f(b=\alpha,m=\beta,p=\gamma;m)$
with $f(\ldots)$ being defined differently depending on $\gamma \in$ `[true,false]`. 

*The value of $f$ for each combination of parameter values is NOT generated in the notebook, but read from datafiles generated by `DrWatson.jl` scripts.* See the `experiments/ex1` folder for more details. Obviously, this is not the most efficient way to go in this particular case, but it serves as an example of more general/useful cases.
"""

# ╔═╡ 57a8e472-d24d-44d0-a8c2-35c056c524ef
df = collect_results(datadir("ex1"));

# ╔═╡ 602c6a8b-5a9d-4aba-9a73-c7af073feed0
cols_to_filter = [:a,:m,:b,:p,:f];

# ╔═╡ 82f442f6-9b3b-46ce-9c91-bb3e54abd526
df_filtered = df[:,cols_to_filter];

# ╔═╡ e4e03f80-42b4-459a-b75a-1e1364b3b659
df_filtered_cols = Dict(pairs(eachcol(df_filtered)));

# ╔═╡ 414e8521-662f-40f9-9c9e-def65d438fc7
params_possible_values=
	    Dict([k=>unique(df_filtered_cols[k]) 
			    for k in keys(df_filtered_cols)]);

# ╔═╡ 17e099ff-caec-4d52-8de8-c3d9f110cf0c


# ╔═╡ e6574182-c313-4f09-b9a7-ad09751ad5ef
md"""
Select the parameter-value combination that you want to visualize!:

a: $(@bind aval Select(params_possible_values[:a])) 
b: $(@bind bval Select(params_possible_values[:b]))
m: $(@bind mval Select(params_possible_values[:m]))
p: $(@bind pval CheckBox())

Customize visualization

legend position: $(@bind lposition Select([:right, :left, :top, :bottom, :inside, :best, :legend, :topright, :topleft, :bottomleft, :bottomright]))

autoxlims: $(@bind autoxlims CheckBox()) 
xlimleft: $(@bind xliml TextField((2,1);default="0.0"))
xlimright: $(@bind xlimr TextField((2,1);default="1.0"))

autoylims: $(@bind autoylims CheckBox())
ylimbottom: $(@bind ylimb TextField((2,1);default="0.0"))
ylimtop: $(@bind ylimt TextField((2,1);default="1.0"))

logx: $(@bind logxval CheckBox()) 
logy: $(@bind logyval CheckBox())

"""

# ╔═╡ 79071a98-5cbc-4ae1-aab6-807a8b77a969
#case = Dict(:n=>n,:k=>k,:fespace=>fespace,:loads=>loads,:disp=>disp,:epsilon=>epsilon,:delta=>delta,:geom=>geom,:solution=>solution);

# ╔═╡ 5748a503-4534-462a-b485-386d68fe857d
function generate_labels(params_possible_values)
  dl=dict_list(params_possible_values)
  labels=Vector{String}(undef,length(dl))
  for (i,d) in enumerate(dl)
	label=""
	for (key,val) in d
	  label=label * " $(key)=$(val)"
	end
	labels[i]=label  
  end
  labels
end 

# ╔═╡ 2c7a1e9b-ebe7-4631-a14d-0c2ea0d7293b
function get_x_y(xparam, yparam, ffilter, df)
  df_filtered = filter(ffilter,df)
  df_filtered_cols = Dict(pairs(eachcol(df_filtered)))
  @assert xparam in keys(df_filtered_cols)
  @assert yparam in keys(df_filtered_cols)
	
  params_possible_values=
	    Dict([k=>unique(df_filtered_cols[k]) 
			    for k in keys(df_filtered_cols) if k != xparam && k != yparam])
	
  dl=dict_list(params_possible_values)

  # The following code is general enough so that for 
  # fixed (xparam, yparam) there might be several 
  # possible combinations for the rest of parameters
  # after applying ffilter. In such a case we generate
  # as many curves as combinations of the rest of 
  # parameter values.
  xall=[]
  yall=[]	
  for d in dl
      function f(a...)
		  all(a .≈ values(d))
	  end 
	  ffilter_current_d = collect(keys(d))=>f
	  df_tmp=filter(ffilter_current_d,df_filtered)
	  sort!(df_tmp,[xparam,])
      x = df_tmp[!,xparam]
      y = df_tmp[!,yparam]
      push!(xall,x)
	  push!(yall,y)
  end
  (xall,yall,params_possible_values)
end


# ╔═╡ 9478d88e-bc39-40b2-be09-3789e4fff51e
function plot_xparam_versus_yparam(xparam,yparam,xaxis,yaxis,ffilter,df;
                                   autoxlims=true,
                                   autoylims=true,
                                   xliml=0.0,
                                   xlimr=1.0,
                                   ylimb=0.0,
                                   ylimt=1.0)
  f = plot()
  x,y,params_possible_values = get_x_y(xparam,yparam,ffilter,df)
  labels=generate_labels(params_possible_values)
  @assert length(x)==length(y)
  @assert length(labels)==length(y)	
  for (xi,yi,li) in zip(x,y,labels)
    plot!(xi,yi,xaxis=xaxis,yaxis=yaxis,label=li,markershape=:auto)
  end 
  plot!(xlabel="$xparam",ylabel="$yparam",legend=lposition)
  if (!autoxlims)
    xlims!((xliml,xlimr))
  end	  
  if (!autoylims)
    ylims!((ylimb,ylimt))
  end	
  f
end

# ╔═╡ 8cdaefc4-2d08-4797-83e2-32790d9989c1
plot_xparam_versus_yparam(:a,:f,
	                      (logxval ? :log10 : :none),
	                      (logyval ? :log10 : :none),
                          [:m,:p,:b]=>(m,p,b)->(m==mval && b==bval && p==pval),
	                      df_filtered;
                          autoxlims=autoxlims,
						  autoylims=autoylims,
                          xliml=parse(Float64, xliml),xlimr=parse(Float64, xlimr),
						  ylimb=parse(Float64, ylimb),ylimt=parse(Float64, ylimt))


# ╔═╡ c147181e-dd4b-4dfd-94c4-ce5435b431f2
plot_xparam_versus_yparam(:b,:f,
	                      (logxval ? :log10 : :none),
	                      (logyval ? :log10 : :none),
                          [:m,:a,:p]=>(m,a,p)->(m==mval && a==aval && p==pval),
	                      df_filtered;
                          autoxlims=autoxlims,
						  autoylims=autoylims,
                          xliml=parse(Float64, xliml),xlimr=parse(Float64, xlimr),
						  ylimb=parse(Float64, ylimb),ylimt=parse(Float64, ylimt))

# ╔═╡ 048f4e43-731e-42ee-a085-85e4502f63a5
plot_xparam_versus_yparam(:m,:f,
	                      (logxval ? :log10 : :none),
	                      (logyval ? :log10 : :none),
                          [:a,:b,:p]=>(a,b,p)->(a==aval && b==bval && p==pval),
	                      df_filtered;
                          autoxlims=autoxlims,
						  autoylims=autoylims,
                          xliml=parse(Float64, xliml),xlimr=parse(Float64, xlimr),
						  ylimb=parse(Float64, ylimb),ylimt=parse(Float64, ylimt))

# ╔═╡ Cell order:
# ╟─106ded38-479d-4961-a127-24c2b416aa9d
# ╠═38e1939a-3c91-4b7b-88fd-ae7e01eda602
# ╠═299c6e30-9107-4039-a11c-32ed6d9b1460
# ╠═b881120b-853d-4c0f-bcb8-b3b18e2dd9ae
# ╠═52a4a234-a99c-4e0d-b1e7-f54ddc11ff45
# ╠═08a6ab1f-ef85-41a3-bb1a-933d578e4f93
# ╠═696ffce0-e025-409c-8628-48b06fc7fd38
# ╠═e82ad202-94eb-4f79-8aa3-7dd40375328b
# ╠═57a8e472-d24d-44d0-a8c2-35c056c524ef
# ╠═602c6a8b-5a9d-4aba-9a73-c7af073feed0
# ╠═82f442f6-9b3b-46ce-9c91-bb3e54abd526
# ╠═e4e03f80-42b4-459a-b75a-1e1364b3b659
# ╠═414e8521-662f-40f9-9c9e-def65d438fc7
# ╟─17e099ff-caec-4d52-8de8-c3d9f110cf0c
# ╟─e6574182-c313-4f09-b9a7-ad09751ad5ef
# ╟─79071a98-5cbc-4ae1-aab6-807a8b77a969
# ╠═8cdaefc4-2d08-4797-83e2-32790d9989c1
# ╠═c147181e-dd4b-4dfd-94c4-ce5435b431f2
# ╠═048f4e43-731e-42ee-a085-85e4502f63a5
# ╠═9478d88e-bc39-40b2-be09-3789e4fff51e
# ╠═5748a503-4534-462a-b485-386d68fe857d
# ╠═2c7a1e9b-ebe7-4631-a14d-0c2ea0d7293b
